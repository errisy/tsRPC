namespace rpc {
    export function emitClient(fileNames: string[], compilerOptions: ts.CompilerOptions, compilerHost: ts.CompilerHost) {
        const program = ts.createProgram(fileNames, compilerOptions, compilerHost);
        const sourceFiles = program.getSourceFiles();
        sourceFiles.forEach((sourceFile: ts.SourceFile) => {
            if (sourceFile.fileWatcher) {
                sourceFile.fileWatcher.close();
                sourceFile.fileWatcher = undefined;
            }
            //try to find folder where there is bs-config.js;
            if (/\.rpc\.ts$/ig.test(sourceFile.fileName)) {
                console.log('Remote Procedure Call Compiler will use the folder that contains \'bs-config.js\' as the root for your node js project. Please make sure you have that file.');
                let serviceFileName = sourceFile.fileName.replace(/\.rpc\.ts$/ig, '.client.ts');
                //let cgiFileName = sourceFile.fileName.replace(/\.rpc\.ts$/ig, '.cgi.ts');
                console.log(sourceFile.fileName + ':');
                let serviceFile = buildClientFile(sourceFile);
                //let cgiFile = buildCGIFile(sourceFile);

                //console.log(serviceFile);
                ts.sys.writeFile(serviceFileName, serviceFile);
                //ts.sys.writeFile(cgiFileName, cgiFile);
                fileNames.push(serviceFileName);
                //fileNames.push(cgiFileName);
            }
        });
        function hasRpcServiceDecorator(_class: ts.ClassDeclaration): boolean {
            if (_class.decorators)
                return _class.decorators.some(decorator => {
                    //console.log('hasRpcServiceDecorator');
                    //console.log(decorator);
                    return true;
                })
            return false;
        }
        function hasRpcMemberDecorator(_member: ts.ClassElement): boolean {
            if (_member.decorators)
                return _member.decorators.some(decorator => {
                    //console.log('hasRpcMemberDecorator');
                    //console.log(decorator);
                    return true;
                })
            return false;
        }
        function getParentFolder(path: string): string {
            let slashposition: number = Math.max(path.lastIndexOf('\\'), path.lastIndexOf('\/'));
            if (slashposition > -1) return path.substr(0, slashposition);
            return path;
        }
        function getFileName(path: string): string {
            let slashposition: number = Math.max(path.lastIndexOf('\\'), path.lastIndexOf('\/'));
            if (slashposition > -1) return path.substr(slashposition + 1);
            return path;
        }
        function findRootFolder(path: string): string {
            let parent = getParentFolder(path);
            while (!ts.sys.fileExists(parent + '/bs-config.js')) {
                parent = getParentFolder(parent);
            }
            return parent;
        }
        function getConvertForType(type: string): string {
            if (typeof type == 'string') type = type.replace(/\s+/, '');
            switch (type) {
                case 'string':
                    return "Converter.convertStringResponse";
                case 'number':
                    return "Converter.convertNumberResponse";
                case 'boolean':
                    return "Converter.convertBooleanResponse";
                default:
                    return "Converter.convertJsonResponse";
            }
        }
        function buildClientFile(sourceFile: ts.SourceFile): string {
            let cgiFileName = sourceFile.fileName.replace(/\.rpc\.ts$/ig, '.cgi.js');
            let CGIPath: string = cgiFileName.substr(findRootFolder(cgiFileName).length);
            {
                let filename = sourceFile.fileName;
                let builder: string[] = [];
                
                //add must include for client;
                /*   
                import { Injectable } from '@angular/core';
                import { Http, Response } from '@angular/http';
                import { Observable } from 'rxjs/Observable';
                import 'rxjs/add/operator/map'; 
                import 'rxjs/add/operator/catch';
                import {Converter} from './rpc';
                */
                builder.push("\/\/Client file generated by RPC Compiler.\n");
                builder.push("import { Injectable } from '@angular/core';\n");
                builder.push("import { Http, Response } from '@angular/http';\n");
                builder.push("import { Observable } from 'rxjs/Observable';\n");
                builder.push("import 'rxjs/add/operator/map';\n");
                builder.push("import 'rxjs/add/operator/catch';\n");
                builder.push("import {Converter} from './rpc';\n");
                //builder.push("let $_CGIPath = '{0}'\n".format(CGIPath));

                sourceFile.statements.forEach(statement => sourceFileStatement(statement, builder, 0));
                return builder.join('');
            }
            function sourceFileStatement(statement: ts.Statement, builder: string[], indent: number) {
                console.log(SyntaxKindTable[statement.kind]);

                switch (statement.kind) {
                    case ts.SyntaxKind.ImportDeclaration:
                        
                        let _import: ts.ImportDeclaration = <any>statement;
                        console.log('Import:', _import);
                        importDeclaration(_import, builder, indent);
                        break;
                    case ts.SyntaxKind.ClassDeclaration:
                        {
                            let _class: ts.ClassDeclaration = <any>statement;
                            console.log(bullentIndent(indent) + 'class ' + _class.name.text);

                            builder.push('export class {0} {\n'.format(_class.name.text));
                            //pass http object by constructor;
                            builder.push("{0}constructor(private $_Angular2HttpClient: Http){\n".format(bullentIndent(indent + 1)));
                            builder.push("{0}}\n".format(bullentIndent(indent + 1)));
                            _class.members.filter(hasRpcMemberDecorator)
                                .forEach(member => classMember(member, builder, indent + 1, _class.name.text));
                            builder.push('}\n');
                        }
                        break;
                    case ts.SyntaxKind.ModuleDeclaration:
                        {
                            let _module: ts.ModuleDeclaration = <any>statement;
                            //console.log(bullentIndent(indent) + 'module ' + _module.name.text);
                            if (_module.name) {
                                builder.push('export module {0} {\n'.format(_module.name.text));
                                if (_module.body) if (_module.body.kind == ts.SyntaxKind.ModuleBlock) {
                                    let _moduleBlock: ts.ModuleBlock = <any>_module.body;
                                    _moduleBlock.statements
                                        .filter(blockStatement => blockStatement.kind == ts.SyntaxKind.ClassDeclaration)
                                        .forEach(blockStatement => {
                                            let _class: ts.ClassDeclaration = <any>blockStatement;
                                            builder.push('\texport class {0} {\n'.format(_class.name.text));
                                            //console.log(bullentIndent(indent + 1) + 'class ' + _class.name.text);
                                            _class.members.filter(hasRpcMemberDecorator).
                                                forEach(member => classMember(member, builder, indent + 2, _class.name.text, _module.name.text));
                                            builder.push('\t}\n');
                                        });
                                }
                                builder.push('}\n');
                            }
                        }
                        break;
                }
            }
            function importDeclaration(importDeclare: ts.ImportDeclaration, builder: string[], indent: number) {
                let _moduleName: ts.StringLiteral = <any>importDeclare.moduleSpecifier;
                let _importClause: ts.ImportClause = <any>importDeclare.importClause;
                builder.push(sourceFile.text.substring(importDeclare.pos, importDeclare.end));
            }
            function classMember(member: ts.ClassElement, builder: string[], indent: number, className: string, moduleName?: string) {
                let classDef: string;
                if (moduleName) {
                    classDef = moduleName + '.' + className;
                }
                else {
                    classDef = className;
                }
                switch (member.kind) {
                    case ts.SyntaxKind.MethodDeclaration:
                        {
                            let _method: ts.MethodDeclaration = <any>member;
                            let _name: ts.Identifier = <any>_method.name;
                            let _type = memberType(_method.type);
                            if (_type) {
                                builder.push('{0}public {1}({2}): Observable<{3}>{\n'.format(bullentIndent(indent), _name.text, memberParamenters(_method.parameters), _type));
                            }
                            else {
                                builder.push('{0}public {1}({2}){\n'.format(bullentIndent(indent), _name.text, memberParamenters(_method.parameters)));
                            }
                            builder.push('{0}return this.$_Angular2HttpClient.post(\'{1}\', {2}).map({3});\n'.format(bullentIndent(indent + 1), '{0}?{1}{2}{3}'.format(CGIPath, classDef, '-', _name.text), parameterObject(_method.parameters), getConvertForType(_type)));
                            builder.push('{0}}\n'.format(bullentIndent(indent)));
                        }
                        break;
                    //case ts.SyntaxKind.GetAccessor:
                    //    {
                    //        let _get: ts.GetAccessorDeclaration = <any>member;
                    //        let _name: ts.Identifier = <any>_get.name;
                    //        let _type = memberType(_get.type);
                    //        if (_type) {
                    //            builder.push('{0}public get {1}({2}): Observable<{3}>{\n'.format(bullentIndent(indent), _name.text, memberParamenters(_get.parameters), _type));
                    //        }
                    //        else {
                    //            builder.push('{0}public get {1}({2}){\n'.format(bullentIndent(indent), _name.text, memberParamenters(_get.parameters)));
                    //        }
                            
                    //        builder.push('{0}return this.$_Angular2HttpClient.post(\'{1}\', {2}).map({3});\n'.format(bullentIndent(indent + 1), '{0}?{1}{2}{3}'.format(CGIPath, classDef, '@', _name.text), parameterObject(_get.parameters), getConvertForType(_type)));
                    //        builder.push('{0}}\n'.format(bullentIndent(indent)));
                    //    }
                    //    break;
                    //case ts.SyntaxKind.SetAccessor:
                    //    {
                    //        let _set: ts.SetAccessorDeclaration = <any>member;
                    //        let _name: ts.Identifier = <any>_set.name;
                    //        //console.log(_name.text);
                    //        builder.push('{0}public set {1}({2}){\n'.format(bullentIndent(indent), _name.text, memberParamenters(_set.parameters)));
                    //        builder.push('{0}}\n'.format(bullentIndent(indent)));
                    //    }
                    //    break;
                }
            }
            function memberParamenters(parameters: ts.ParameterDeclaration[]) {
                return parameters.map((parameter) => ('{0}: {1}'.format(parameter.name['text'], memberType(parameter.type)))).join(', ');
            }
            function parameterObject(parameters: ts.ParameterDeclaration[]) {
                return '[{0}]'.format(parameters.map(parameter => '{0}'.format(parameter.name['text'])).join(', '));
            }
            function memberType(_type: ts.TypeNode): string {
                if(_type)
                    return sourceFile.text.substring(_type.pos, _type.end);
                return undefined;
            }

        }
    }



    function bullentIndent(count: number): string {
        let result = '';
        for (let i: number = 0; i < count; i++) {
            result += '\t';
        }
        return result;
    }
    var SyntaxKindTable = ['Unknown', 'EndOfFileToken', 'SingleLineCommentTrivia', 'MultiLineCommentTrivia', 'NewLineTrivia', 'WhitespaceTrivia', 'ShebangTrivia', 'ConflictMarkerTrivia', 'NumericLiteral', 'StringLiteral', 'RegularExpressionLiteral', 'NoSubstitutionTemplateLiteral', 'TemplateHead', 'TemplateMiddle', 'TemplateTail', 'OpenBraceToken', 'CloseBraceToken', 'OpenParenToken', 'CloseParenToken', 'OpenBracketToken', 'CloseBracketToken', 'DotToken', 'DotDotDotToken', 'SemicolonToken', 'CommaToken', 'LessThanToken', 'LessThanSlashToken', 'GreaterThanToken', 'LessThanEqualsToken', 'GreaterThanEqualsToken', 'EqualsEqualsToken', 'ExclamationEqualsToken', 'EqualsEqualsEqualsToken', 'ExclamationEqualsEqualsToken', 'EqualsGreaterThanToken', 'PlusToken', 'MinusToken', 'AsteriskToken', 'AsteriskAsteriskToken', 'SlashToken', 'PercentToken', 'PlusPlusToken', 'MinusMinusToken', 'LessThanLessThanToken', 'GreaterThanGreaterThanToken', 'GreaterThanGreaterThanGreaterThanToken', 'AmpersandToken', 'BarToken', 'CaretToken', 'ExclamationToken', 'TildeToken', 'AmpersandAmpersandToken', 'BarBarToken', 'QuestionToken', 'ColonToken', 'AtToken', 'EqualsToken', 'PlusEqualsToken', 'MinusEqualsToken', 'AsteriskEqualsToken', 'AsteriskAsteriskEqualsToken', 'SlashEqualsToken', 'PercentEqualsToken', 'LessThanLessThanEqualsToken', 'GreaterThanGreaterThanEqualsToken', 'GreaterThanGreaterThanGreaterThanEqualsToken', 'AmpersandEqualsToken', 'BarEqualsToken', 'CaretEqualsToken', 'Identifier', 'BreakKeyword', 'CaseKeyword', 'CatchKeyword', 'ClassKeyword', 'ConstKeyword', 'ContinueKeyword', 'DebuggerKeyword', 'DefaultKeyword', 'DeleteKeyword', 'DoKeyword', 'ElseKeyword', 'EnumKeyword', 'ExportKeyword', 'ExtendsKeyword', 'FalseKeyword', 'FinallyKeyword', 'ForKeyword', 'FunctionKeyword', 'IfKeyword', 'ImportKeyword', 'InKeyword', 'InstanceOfKeyword', 'NewKeyword', 'NullKeyword', 'ReturnKeyword', 'SuperKeyword', 'SwitchKeyword', 'ThisKeyword', 'ThrowKeyword', 'TrueKeyword', 'TryKeyword', 'TypeOfKeyword', 'VarKeyword', 'VoidKeyword', 'WhileKeyword', 'WithKeyword', 'ImplementsKeyword', 'InterfaceKeyword', 'LetKeyword', 'PackageKeyword', 'PrivateKeyword', 'ProtectedKeyword', 'PublicKeyword', 'StaticKeyword', 'YieldKeyword', 'AbstractKeyword', 'AsKeyword', 'AnyKeyword', 'AsyncKeyword', 'AwaitKeyword', 'BooleanKeyword', 'ConstructorKeyword', 'DeclareKeyword', 'GetKeyword', 'IsKeyword', 'ModuleKeyword', 'NamespaceKeyword', 'ReadonlyKeyword', 'RequireKeyword', 'NumberKeyword', 'SetKeyword', 'StringKeyword', 'SymbolKeyword', 'TypeKeyword', 'UndefinedKeyword', 'FromKeyword', 'GlobalKeyword', 'OfKeyword', 'QualifiedName', 'ComputedPropertyName', 'TypeParameter', 'Parameter', 'Decorator', 'PropertySignature', 'PropertyDeclaration', 'MethodSignature', 'MethodDeclaration', 'Constructor', 'GetAccessor', 'SetAccessor', 'CallSignature', 'ConstructSignature', 'IndexSignature', 'TypePredicate', 'TypeReference', 'FunctionType', 'ConstructorType', 'TypeQuery', 'TypeLiteral', 'ArrayType', 'TupleType', 'UnionType', 'IntersectionType', 'ParenthesizedType', 'ThisType', 'StringLiteralType', 'ObjectBindingPattern', 'ArrayBindingPattern', 'BindingElement', 'ArrayLiteralExpression', 'ObjectLiteralExpression', 'PropertyAccessExpression', 'ElementAccessExpression', 'CallExpression', 'NewExpression', 'TaggedTemplateExpression', 'TypeAssertionExpression', 'ParenthesizedExpression', 'FunctionExpression', 'ArrowFunction', 'DeleteExpression', 'TypeOfExpression', 'VoidExpression', 'AwaitExpression', 'PrefixUnaryExpression', 'PostfixUnaryExpression', 'BinaryExpression', 'ConditionalExpression', 'TemplateExpression', 'YieldExpression', 'SpreadElementExpression', 'ClassExpression', 'OmittedExpression', 'ExpressionWithTypeArguments', 'AsExpression', 'NonNullExpression', 'TemplateSpan', 'SemicolonClassElement', 'Block', 'VariableStatement', 'EmptyStatement', 'ExpressionStatement', 'IfStatement', 'DoStatement', 'WhileStatement', 'ForStatement', 'ForInStatement', 'ForOfStatement', 'ContinueStatement', 'BreakStatement', 'ReturnStatement', 'WithStatement', 'SwitchStatement', 'LabeledStatement', 'ThrowStatement', 'TryStatement', 'DebuggerStatement', 'VariableDeclaration', 'VariableDeclarationList', 'FunctionDeclaration', 'ClassDeclaration', 'InterfaceDeclaration', 'TypeAliasDeclaration', 'EnumDeclaration', 'ModuleDeclaration', 'ModuleBlock', 'CaseBlock', 'GlobalModuleExportDeclaration', 'ImportEqualsDeclaration', 'ImportDeclaration', 'ImportClause', 'NamespaceImport', 'NamedImports', 'ImportSpecifier', 'ExportAssignment', 'ExportDeclaration', 'NamedExports', 'ExportSpecifier', 'MissingDeclaration', 'ExternalModuleReference', 'JsxElement', 'JsxSelfClosingElement', 'JsxOpeningElement', 'JsxText', 'JsxClosingElement', 'JsxAttribute', 'JsxSpreadAttribute', 'JsxExpression', 'CaseClause', 'DefaultClause', 'HeritageClause', 'CatchClause', 'PropertyAssignment', 'ShorthandPropertyAssignment', 'EnumMember', 'SourceFile', 'JSDocTypeExpression', 'JSDocAllType', 'JSDocUnknownType', 'JSDocArrayType', 'JSDocUnionType', 'JSDocTupleType', 'JSDocNullableType', 'JSDocNonNullableType', 'JSDocRecordType', 'JSDocRecordMember', 'JSDocTypeReference', 'JSDocOptionalType', 'JSDocFunctionType', 'JSDocVariadicType', 'JSDocConstructorType', 'JSDocThisType', 'JSDocComment', 'JSDocTag', 'JSDocParameterTag', 'JSDocReturnTag', 'JSDocTypeTag', 'JSDocTemplateTag', 'SyntaxList', 'Count'];
}
interface String {
    format(...args: string[]): string;
}
String.prototype.format = (...args: string[]): string => {
    var that: string = <string>eval('this');
    return that.replace(/{\d+}/g, (char: string): string => {
        var index: number = Number(char.substr(1, char.length - 2));
        return args[index];
    });
}